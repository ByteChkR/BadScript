 namespace System.Enumerables { class Repeat : Enumerable { _obj = 0 function Repeat(obj) { _obj = obj } function MoveNext() { return true } function GetCurrent() { return _obj } function ToString() { return "Repeat Enumerable(" + _obj + ")" } } } namespace System.Enumerables { class Range : Enumerable { _current = null _end = 0 _start = 0 function Range(!start, !end) { if(start == null) { Environment.Error("Assertion Failed. var is NULL.") } if(!Convert.IsNumber(start)) { Environment.Error("Assertion Failed. var is not a number. Actual Value: " + start) } if(end == null) { Environment.Error("Assertion Failed. var is NULL.") } if(!Convert.IsNumber(end)) { Environment.Error("Assertion Failed. var is not a number. Actual Value: " + end) } _start = start _end = end } function MoveNext() { if(_current == null) { _current = _start return true } _current += 1 return _current <= _end } function GetCurrent() { return _current } function ToString() { return "Range Enumerable(" + _start + " - " + _end + ")" } } } namespace System.Enumerables { Math = Environment.LoadInterface("Math") class PrimeNumbers : Enumerable { _current = null _end = 0 _start = 0 function PrimeNumbers(!start, !end) { if(start == null) { Environment.Error("Assertion Failed. var is NULL.") } if(!Convert.IsNumber(start)) { Environment.Error("Assertion Failed. var is not a number. Actual Value: " + start) } if(end == null) { Environment.Error("Assertion Failed. var is NULL.") } if(!Convert.IsNumber(end)) { Environment.Error("Assertion Failed. var is not a number. Actual Value: " + end) } _start = start _end = end } function FindNextPrime() { while(!Math.IsPrime(_current)) { _current += 1 if(_current > _end) { break } } } function MoveNext() { if(_current == null) { _current = _start FindNextPrime() return _current <= _end } _current += 1 FindNextPrime() return _current <= _end } function GetCurrent() { return _current } function ToString() { return "Range Enumerable(" + _start + " - " + _end + ")" } } } namespace System.Enumerables { class OddNumbers : Enumerable { _current = null _end = 0 _start = 0 function OddNumbers(!start, !end) { if(start == null) { Environment.Error("Assertion Failed. var is NULL.") } if(!Convert.IsNumber(start)) { Environment.Error("Assertion Failed. var is not a number. Actual Value: " + start) } if(end == null) { Environment.Error("Assertion Failed. var is NULL.") } if(!Convert.IsNumber(end)) { Environment.Error("Assertion Failed. var is not a number. Actual Value: " + end) } _start = start _end = end isOdd = _start % 2 if( isOdd != 1 ) { _current = _start - 1 } } function MoveNext() { if(_current == null) { _current = _start return true } _current += 2 return _current <= _end } function GetCurrent() { return _current } function ToString() { return "EvenNumbers Enumerable(" + _start + " - " + _end + ")" } } } namespace System.Enumerables { class EvenNumbers : Enumerable { _current = null _end = 0 _start = 0 function EvenNumbers(!start, !end) { if(start == null) { Environment.Error("Assertion Failed. var is NULL.") } if(!Convert.IsNumber(start)) { Environment.Error("Assertion Failed. var is not a number. Actual Value: " + start) } if(end == null) { Environment.Error("Assertion Failed. var is NULL.") } if(!Convert.IsNumber(end)) { Environment.Error("Assertion Failed. var is not a number. Actual Value: " + end) } _start = start _end = end isOdd = _start % 2 if( isOdd == 1 ) { _current = _start - 1 } } function MoveNext() { if(_current == null) { _current = _start return true } _current += 2 return _current <= _end } function GetCurrent() { return _current } function ToString() { return "EvenNumbers Enumerable(" + _start + " - " + _end + ")" } } } namespace System.Enumerables { class Enumerable { function MoveNext() { Environment.Error( GetType() + " does not override MoveNext()") } function GetCurrent() { Environment.Error( GetType() + " does not override GetCurrent()") } } } namespace System.Vectors { Math = Environment.LoadInterface("Math", {}) class Vector4 { X = 0 Y = 0 Z = 0 W = 0 function Vector4(x, y, z, w) { X = x Y = y Z = z W = w } function Add(other) { return new Vector4( X + other.X, Y + other.Y, Z + other.Z, W + other.W) } function Sub(other) { return new Vector4( X - other.X, Y - other.Y, Z - other.Z, W - other.W) } function Scale(scalar) { return new Vector4( X * scalar, Y * scalar, Z * scalar, W * scalar) } function SqrMagnitude() { return X + Y + Z + W } function Magnitude() { return Math.Sqrt(SqrMagnitude()) } function Normalized() { return Scale(1 / Magnitude()) } function op_Addition(other) { if(Convert.IsType(other)) { return Add(other) } else { Console.WriteLine(Debug(other)) Environment.Error("Can only Add a Vector with a Vector.") } } function op_Subtraction(other) { if(Convert.IsType(other)) { return Sub(other) } else { Environment.Error("Can only Add a Vector with a Vector.") } } function op_Multiply(other) { if(Convert.IsType(other)) { Environment.Error("Can not Multiply Two Vectors. Right side has to be scalar") } else { return Scale(other) } } function op_Division(other) { if(Convert.IsType(other)) { Environment.Error("Can not Multiply Two Vectors. Right side has to be scalar") } else { return Scale(1 / other) } } function op_Equality(other) { if(Convert.IsType(other)) { return X == other.X && Y == other.Y && Z == other.Z && W == other.W } return false } function op_Inequality(other) { return op_Equals(other) == false } } class Vector3 : Vector4 { function Vector3(x, y, z) : base(x, y, z, 0) {} } class Vector2 : Vector3 { function Vector2(x, y) : base(x, y, 0) {} } } namespace System { if(!Environment.HasInterface("String")) { Environment.Error("Assertion Failed. Interface String is not available") } String = Environment.LoadInterface("String") class Str { _str = null function Str(!str) { if(str == null) { Environment.Error("Assertion Failed. var is NULL.") } if(!Convert.IsString(str)) { Environment.Error("Assertion Failed. var is not a string. Actual Value: " + str) } _str = str } function Length() { return String.Length(_str) } function SubString(start, length) { return new Str(String.Substr(_str, start, length)) } function Remove(start, length) { return new Str(String.Remove(_str, start, length)) } function ToNumber() { return Convert.ToNumber(_str) } function Trim() { return new Str(String.Trim(_str)) } function TrimStart() { return new Str(String.TrimStart(_str)) } function TrimEnd() { return new Str(String.TrimEnd(_str)) } function Split(*splits) { strs = String.Split(_str, splits) for i = 0 while< strs.size() { strs[i] = new Str(strs[i]) } return strs } function CharAt(i) { return new Str(String.CharAt(_str, i)) } function EndsWith(str) { return String.EndsWith(_str, str) } function StartsWith(str) { return String.StartsWith(_str, str) } function IndexOf(searchStr) { return String.IndexOf(_str, searchStr) } function Insert(i, str) { return new Str(String.Insert(_str, i, str)) } function LastIndexOf(searchStr) { return String.LastIndexOf(_str, searchStr) } function Replace(oldStr, newStr) { return new Str(String.Replace(_str, oldStr, newStr)) } function ToArray() { return String.ToArray(_str) } function IsLetter(?i) { i = i ?? 0 return String.IsLetter(CharAt(i)) } function IsWhiteSpace(?i) { i = i ?? 0 return String.IsWhiteSpace(CharAt(i)) } function IsDigit(?i) { i = i ?? 0 return String.IsDigit(CharAt(i)) } function ToLower() { return new Str(String.ToLower(_str)) } function Format(*args) { args.Insert(0, _str) return new Str(String.Format.Invoke(args, true)) } function op_ArrayAccess(i) { return CharAt(i) } function op_SelfAddition(other) { return op_Addition(other) } function op_Equality(other) { if(Environment.DefaultOp("==", other, null)) { return false } if(Convert.IsString(other)) { return _str == other } if(Convert.IsType(other)) { return other.IsInstanceOf(this) } return false } function op_Inequality(other) { return !op_Equality(other) } function op_Addition(other) { if(other == null) { return new Str(_str + "NULL") } else if(Convert.IsString(other)) { return new Str(_str + other) } else if(Convert.IsType(other)) { if(other.IsInstanceOf(this)) { return new Str(_str + other.ToString()) } } Environment.Error("Can not Apply 'op_Addition' to String and object " + other) return null } function ToString() { return _str } } } namespace System.Logging { class Logger { function Write(obj) { Environment.Error("No implementation for 'Logger.Write' in type " + GetType()) } function WriteLine(obj) { Environment.Error("No implementation for 'Logger.WriteLine' in type " + GetType()) } function Clear() { Environment.Error("No implementation for 'Logger.Clear' in type " + GetType()) } } class ConsoleLogger : Logger { function Write(obj) => Console.Write(obj) function WriteLine(obj) => Console.WriteLine(obj) function Clear() => Console.Clear() } } namespace System { class Event { _listeners = [] _argcount = 0 _collectReturns = false function Event(?argc, ?aggregateReturns) { _argcount = argc if(_argcount == null) { _argcount = 0 } _collectReturns = aggregateReturns if(_collectReturns == null) { _collectReturns = false } } function AddListener(event) { if(Convert.IsFunction(event)) { _listeners.Add(event) return this } Environment.Error("Can not add '" + Debug(event) + "' to Event Handler") } function RemoveListener(event) { if(Convert.IsFunction(event)) { _listeners.Remove(event) return this } Environment.Error("Can not remove '" + Debug(event) + "' from Event Handler") } function Invoke(*args) { if(args.Size() != _argcount) { Environment.Error("Invalid Argument Count. Expected: " + _argcount + " but got " + args.Size()) return null } if(_collectReturns) { r = [] foreach subscriber in _listeners { sr = subscriber.Invoke(args) r.Add(sr) } return r } foreach subscriber in _listeners { subscriber.Invoke(args) } return null } function ClearListeners() => _listeners.Clear() op_SelfAddition = AddListener op_SelfSubtraction = RemoveListener op_Invoke = Invoke } } 