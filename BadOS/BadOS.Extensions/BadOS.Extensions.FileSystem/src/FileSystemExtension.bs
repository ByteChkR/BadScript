
namespace BadOS.Extensions.FileSystem
{
	using BadOS.Core.Extensions

	class FileSystemExtension : Extension
	{
		_logger = null
		_rootFS = null
		_rootLink = null
		_rootUser = null
		_userManager = null
		_additionalFs = []
		_pathResolver = null
		function FileSystemExtension(!rootFs, ?additionalFs)
		{
			#ASSERT_INSTANCE_OF(FileSystem, rootFs)
			if(additionalFs != null)
			{
				#ASSERT_ARRAY(additionalFs)
				_additionalFs = additionalFs
			}
			_rootFS = rootFs
		}
		#EXTENSION_GENERATE_INFO_BODY()
		function Initialize(!host) : base(host)
		{
			l = host.GetExtension("BadOS.Extensions.Logging")
			_userManager = host.GetExtension("BadOS.Extensions.UserManagement")
			_logger = l.CreateLogger(GetName())


			node = new FileSystemLink()
			node._Logger = _logger
			root = _userManager.GetRoot()
			node._OwnerUID = root.GetUID()
			node._Name = ""
			node._Parent = null
			node._FileSystem = _rootFS

			_logger.Log($"Mounting File System '{_rootFS.GetName()}' for UID {root.GetUID()} in '/'")
			node.LoadFileSystemEntries()
			devs = node.CreateDirectory(root, "devs")
			
			devs.CreateLink(root, _rootFS.GetName(), node)

			foreach afs in _additionalFs
			{
				devs.MountFileSystem(root, afs.GetName(), afs)
			}

			_rootLink = node

			_pathResolver = new PathResolver()

			_rootUser = root

			_Host.RegisterShutdownHandler(SaveFileSystemNodes)
			ApplyFileSystemNodes()
		}

		function GetNodeDataFile()
		{
			return CreateFile(_rootUser, GetRootNode(), "/sys/FileSystem/NodeData.json")
		}

		function HasNodeDataFile()
		{
			return Exists(GetRootNode(), "/sys/FileSystem/NodeData.json")
		}

		function SaveFileSystemNodes()
		{
			_logger.Log($"Saving File System Nodes")
			data = CreateRootData()
			nodeFile = GetNodeDataFile()

			nodeFile.WriteJson(_rootUser, data)
		}

		function ApplyFileSystemNodes()
		{
			_logger.Log($"Loading File System Nodes")
			if(HasNodeDataFile())
			{
				nodeFile = GetNodeDataFile()
				data = nodeFile.ReadJson(_rootUser)
				node = GetRootNode()
				InnerApplyNodeData(node, data)
			}
		}

		function InnerApplyNodeData(!node, !data)
		{
			for i = 0 while< node.GetChildCount()
			{
				child = node.GetChildAt(i)
				childData = null
				foreach cData in data.Children
				{
					if(child.GetName() == cData.Name)
					{
						childData = cData
						break
					}
				}
				if(childData != null)
				{
					ApplyNodeData(child, childData)
				}
			}
		}
		function ApplyNodeData(!node, !data)
		{
			#ASSERT_INSTANCE_OF(FileSystemNode, node)
			node._OwnerUID = data.UID
			if(node.IsDirectory())
			{
				InnerApplyNodeData(node, data)
			}
		}


		function CreateRootData()
		{
			node = GetRootNode()
			data = {
					Children = []
				}
			for i = 0 while< node.GetChildCount()
			{
				child = node.GetUnresolvedChildAt(i)
				childData = CreateNodeData(child)
				if(childData != null)
				{
					data.Children.Add(childData)
				}
			}
			return data
		}
		function CreateNodeData(!node)
		{
			#ASSERT_INSTANCE_OF(FileSystemNode, node)

			data = {
					Name = node.GetName(),
					UID = node.GetOwnerUID(),
					Children = []
				}

			if(node.IsFile())
			{
				return data
			}
			else if(node.IsDirectory() && !node.IsFileSystemLink())
			{
				for i = 0 while< node.GetChildCount()
				{
					child = node.GetChildAt(i)
					childData = CreateNodeData(child)
					if(childData != null)
					{
						data.Children.Add(childData)
					}
				}
				return data
			}
			else
			{
				return null
			}
		}

		function GetRootFS()
		{
			return _rootFS
		}
		function GetRootNode()
		{
			return _rootLink
		}

		function GetFileName(!path)
		{
			return _pathResolver.GetFileName(path)
		}
		function GetDirectoryPath(!path)
		{
			return _pathResolver.GetDirectoryPath(path)
		}

		function CreateFile(!user, !startNode, !path)
		{
			if(String.StartsWith(path, "/"))
			{
				path = String.Remove(path, 0, 1)
			}

			parts = String.Split(path, "/")

			current = startNode
			for i = 0 while< parts.Size()-1
			{
				part = parts[i]
				if(current.IsDirectory())
				{
					next = current.GetChild(part)
					if(next != null)
					{
						current = next
					}
					else
					{
						current = current.CreateDirectory(user, part)
					}
				}
				else if(current.IsFile())
				{
					Environment.Error($"Can not Create Directory: '{current.ToString()}' already exists")
				}
				else
				{
					Environment.Error($"Can not Find Through Node: {current.ToString()}")
				}
			}
			file = current.GetChild(parts[parts.Size() - 1])
			if(file == null)
			{
				file = current.CreateFile(user, parts[parts.Size() - 1])
			}
			return file
		}

		function ResolvePath(!path, ?currentPath) => return _pathResolver.ResolvePath(path, currentPath)

		function CreateDirectory(!user, !startNode, !path)
		{
			if(String.StartsWith(path, "/"))
			{
				path = String.Remove(path, 0, 1)
			}

			parts = String.Split(path, "/")

			current = startNode
			for i = 0 while< parts.Size()
			{
				part = parts[i]
				if(current.IsDirectory())
				{
					next = current.GetChild(part)
					if(next != null)
					{
						current = next
					}
					else
					{
						current = current.CreateDirectory(user, part)
					}
				}
				else if(current.IsFile())
				{
					Environment.Error($"Can not Create Directory: '{current.ToString()}' already exists")
				}
				else
				{
					Environment.Error($"Can not Find Through Node: {current.ToString()}")
				}
			}
			return current
		}

		function Exists(!startNode, !path)
		{
			if(path == "/")
			{
				return true
			}
			if(String.StartsWith(path, "/"))
			{
				path = String.Remove(path, 0, 1)
			}

			parts = String.Split(path, "/")

			current = startNode
			for i = 0 while< parts.Size()
			{
				part = parts[i]
				if(current.IsDirectory())
				{
					next = current.GetChild(part)
					if(next != null)
					{
						current = next
					}
					else
					{
						return false
					}
				}
				else if(current.IsFile() && i != parts.Size() - 1)
				{
					return false
				}
				else
				{
					Environment.Error($"Can not Find Through Node: {current.ToString()}")
				}
			}
			return true
		}

		function FindNode(!startNode, !path)
		{
			if(path == "/")
			{
				return GetRootNode()
			}
			if(String.StartsWith(path, "/"))
			{
				path = String.Remove(path, 0, 1)
			}

			parts = String.Split(path, "/")

			current = startNode
			for i = 0 while< parts.Size()
			{
				part = parts[i]
				if(current.IsDirectory())
				{
					next = current.GetChild(part)
					if(next != null)
					{
						current = next
					}
					else
					{
						Environment.Error($"Find Node Path '{path}' does not exist in the starting node '{startNode.GetFullName()}'")
					}
				}
				else if(current.IsFile() && i != parts.Size() - 1)
				{
					Environment.Error($"Find Node Path '{path}' does not exist in the starting node '{startNode.GetFullName()}'")
				}
				else
				{
					Environment.Error($"Can not Find Through Node: {current.ToString()}")
				}
			}
			return current
		}

		function GetPublicInterface()
		{
			t = base.GetPublicInterface()
			t.GetAccessRight = GetAccessRight
			t.GetRootFS = GetRootFS
			t.GetRootNode = GetRootNode
			t.FindNode = FindNode
			t.CreateDirectory = CreateDirectory
			t.CreateFile = CreateFile
			t.ResolvePath = ResolvePath
			t.GetFileName = GetFileName
			t.GetDirectoryPath = GetDirectoryPath
			t.Exists = Exists
			return t
		}
	}
}