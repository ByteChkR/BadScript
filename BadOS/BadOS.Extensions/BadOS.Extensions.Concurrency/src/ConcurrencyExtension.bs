
namespace BadOS.Extensions.Concurrency
{
	using BadOS.Core.Extensions
	using BadOS.Core.Events
	class ProcessStartEvent : Event
	{
		_User = null
		_Src = null
		_Args = null
		_WDir = null
		_Name = null

		function ProcessStartEvent(!user, !src, ?args, ?wDir, ?name)
		{
			_User = user
			_Src = src
			_Args = args
			_WDir = wDir
			_Name = name
		}
		function GetUser() => return _User
		function GetName() => return _Name
		function GetSource() => return _Src
		function GetArguments() => return _Args
		function GetWorkingDirectory() => return _WDir

		function GetEventKey()
		{
			return "OS_PROC_START"
		}

		function GetReceiveRight()
		{
			return $"{GetEventKey()}.Receive"
		}
	}
	class ConcurrencyExtension : Extension
	{

		#EXTENSION_GENERATE_INFO_BODY()

		_Logger = null
		_ThreadingApi = null
		_RootProcess = null
		_LastProcessId = 0
		_UserSystem = null
		_Env = null
		_ExtensionSystem = null
		_FileSystem = null
		function ConcurrencyExtension(!environment)
		{
			_ThreadingApi = environment.LoadInterface("Threading", {})
			
			_Env = environment
		}


		function GetCurrentlyExecutingProcess()
		{
			threadID = _ThreadingApi.CurrentThread.ThreadID
			procs = _RootProcess.FindAll(function(p) => return p.GetThreadID() == threadID )
			

			proc = null
			for i = 0 while< procs.Size()
			{
				pr = procs[i]
				if(pr.IsActive())
				{
					proc = pr
					break
				}
			}
			return proc
		}

		function ReapOrphans()
		{
			_RootProcess.ReapChildren()
		}

		function GetPublicInterface()
		{
			t = base.GetPublicInterface()
			t.GetAccessRight = GetAccessRight
			t.WriteProcessList = WriteProcessList
			t.GetProcess = GetProcess
			t.StartTask = StartTask
			t.StartProcess = StartProcess
			t.StartSynchronousProcess = StartSynchronousProcess
			t.ReapOrphans = ReapOrphans
			return t
		}
		function OnProcessStart(!ev)
		{
			#ASSERT_INSTANCE_OF(ProcessStartEvent, ev)
			StartProcess(ev.GetUser(), ev.GetSource(), ev.GetArguments(), ev.GetWorkingDirectory(), ev.GetName())
		}

		function OnShutdown(!ev)
		{
			_RootProcess.RequestAllChildrenExit()
			ReapOrphans()
		}
		function OnUpdate(!ev)
		{
			ReapOrphans()
		}

		function Initialize(!host) : base(host)
		{
			l = host.GetExtension("BadOS.Extensions.Logging")
			eventSystem = host.GetEventSystem()
			eventSystem.AddHandler(new ProcessStartHandler(OnProcessStart))
			eventSystem.AddHandler(new OnShutdownHandler(OnShutdown))
			eventSystem.AddHandler(new OnUpdateHandler(OnUpdate))
			_Logger = l.CreateLogger(GetName())


			_UserSystem = _Host.GetExtension("BadOS.Extensions.UserManagement")
			_ExtensionSystem = _Host.GetExtension("BadOS.Core.Extensions.CoreExtension")

			_FileSystem = _Host.GetExtension("BadOS.Extensions.FileSystem")
			_RootUser = _UserSystem.GetRoot()

			thread = _ThreadingApi.CurrentThread
			_RootProcess = new Process()
			_RootProcess._ThreadInfo = CreateProcessInfo(null, _RootUser, [], "/", "System Process")
			_RootProcess._ThreadInfo.PID = 0
			_RootProcess._Parent = null
			_RootProcess._Thread = thread
			_RootProcess.SetActive(true)

		}

		function WriteProcessList(!user)
		{
			#EXTENSION_ASSERT_USER_HAS_RIGHT(user, Process.List)
			function MakeIndentWriter()
			{
				ind = 0
				return {
					Write = function(obj)
					{
						s = ""
						for i = 0 while< ind
						{
							s+= "|\t"
						}
						_Logger.Log(s+obj)
					},
					Increase = function()
					{
						ind += 1
					},
					Decrease = function()
					{
						ind -= 1
					}
				}
			}

			iw = MakeIndentWriter()

			_RootProcess.WriteProcessMap(iw)
		}

		function CreateProcessInfo(curProcess, !user, !args, ?wDir, ?name)
		{
			
			#ASSERT_ARRAY(args)
			if(wDir != null)
			{
				#ASSERT_STRING(wDir)
			}
			else
			{
				info = curProcess.GetInfo()
				wDir = info.GetWorkingDirectory()
			}

			if(name != null)
			{
				#ASSERT_STRING(name)
			}
			else
			{
				name = "UnnamedProcess"
			}
			pubInfo = {}

			pinfo = {
				Name = name,
				PID = -1,
				WorkingDirectory = wDir,
				ExitRequested = false,
				Arguments = a,
				User = user,
				GetPublicInfo = function() => return pubInfo,
				ResolvePath = function(!path) => return _FileSystem.ResolvePath(path, pinfo.WorkingDirectory),
				GetWorkingNode = function() => return _FileSystem.FindNode(_FileSystem.GetRootNode(), pinfo.WorkingDirectory)
			}
			pubInfo.GetExitRequested = function() => return pinfo.ExitRequested
			pubInfo.GetName = function() => return pinfo.Name
			pubInfo.GetPID = function() => return pinfo.PID
			pubInfo.GetWorkingDirectory = function() => return pinfo.WorkingDirectory
			pubInfo.GetWorkingNode = pinfo.GetWorkingNode
			pubInfo.GetUser = function() => return pinfo.User
			pubInfo.ResolvePath = pinfo.ResolvePath

			pubInfo.SetName = function(!name)
			{
				#ASSERT_STRING(name)
				pinfo.Name = name
			}
			pubInfo.SetWorkingDirectory = function(!dir)
			{
				#ASSERT_STRING(dir)
				pinfo.WorkingDirectory = dir
			}
			pubInfo.GetArguments = function()
			{
				a = []
				foreach arg in args
				{
					a.Add(arg)
				}
				return a
			}
			return pinfo
		}

		function GetProcess(!user, !pid)
		{
			#EXTENSION_ASSERT_USER_HAS_RIGHT(user, Process.Get)
			#ASSERT_NUMBER(pid)
			proc = _RootProcess.FindProcess(pid)
			return proc
		}

		function StartTask(!user, !func, ?args)
		{
			#EXTENSION_ASSERT_USER_HAS_RIGHT(user, Task.Start)

			if(args == null)
			{
				args = [func]
			}
			else
			{
				args.Insert(0, func)
			}
			return _ThreadingApi.CreateTask.Invoke(args)
		}

		function PrepareScope(!pinfo)
		{
			scope = _Env.CreateScope()
			_Env.LoadScopedString(scope, "ProcessInfo = args[0]\nExtensions = args[1]", pinfo, _ExtensionSystem)
			_Env.ResetScope(scope)
			return scope
		}

		function StartText(!pinfo, !text, ?args)
		{
			#ASSERT_STRING(text)
			scope = PrepareScope(pinfo)

			a = [scope, text]
			if(args != null)
			{
				#ASSERT_ARRAY(args)
				foreach arg in args
				{
					a.Add(arg)
				}
			}

			return _Env.LoadScopedString.Invoke(a)
		}

		function StartSynchronousProcess(!user, !src, !args, ?wDir, ?name)
		{

			#EXTENSION_ASSERT_USER_HAS_RIGHT(user, Process.Start)
			parentProcess = GetCurrentlyExecutingProcess()

			pinfo = CreateProcessInfo(parentProcess, user, args, wDir, name)

			_LastProcessId += 1
			pinfo.PID = _LastProcessId

			proc = new Process()
			proc._ThreadInfo = pinfo
			proc._Thread = null
			parentProcess.AddChild(proc)
			

			parentProcess.SetActive(false)
			proc.SetActive(true)

			ret = StartText(proc.GetInfo(), src, args)

			parentProcess.SetActive(true)

			proc.SetActive(false)
			proc.SetDead()
			return ret
		}

		function StartProcess(!user, !src, ?args, ?wDir, ?name)
		{

			#EXTENSION_ASSERT_USER_HAS_RIGHT(user, Process.Start)
			parentProcess = GetCurrentlyExecutingProcess()

			pinfo = CreateProcessInfo(parentProcess, user, args, wDir, name)

			_LastProcessId += 1
			pinfo.PID = _LastProcessId

			proc = new Process()
			proc._ThreadInfo = pinfo


			thread = _ThreadingApi.CreateThread(StartText, proc.GetInfo(), src, args)
			proc._Thread = thread
			parentProcess.AddChild(proc)
			proc.SetActive(true)
			thread.Start()
			return proc
		}

	}
}