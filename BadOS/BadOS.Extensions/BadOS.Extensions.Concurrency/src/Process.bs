namespace BadOS.Extensions.Concurrency
{

	class Process
	{
		_Children = []
		_Parent = null
		_Thread = null
		_IsActiveProcess = false
		_ForceDead = false
		_ThreadInfo = {
			Name = "UnnamedProcess",
			PID = -1,
			ExitRequested = false,
			WorkingDirectory = null,
			Arguments = null,
			User = null
		}
		function AddChild(!process)
		{
			#ASSERT_INSTANCE_OF(Process, process)

			_Children.Add(process)
			process._Parent = this
		}

		function RequestExit()
		{
			_ThreadInfo.ExitRequested = true
		}
		function RequestAllExit()
		{
			RequestAllChildrenExit()
			RequestExit()
		}

		function RequestAllChildrenExit()
		{
			foreach	child in _Children
			{
				child.RequestAllExit()
			}
		}

		function InterruptAll()
		{
			InterruptAllChildren()
			Interrupt()
		}

		function InterruptAllChildren()
		{
			foreach	child in _Children
			{
				child.InterruptAll()
			}
		}

		function IsActive()
		{
			return _IsActiveProcess
		}

		function SetActive(!state)
		{
			#ASSERT_BOOL(state)
			_IsActiveProcess = state
		}

		function GetInfo()
		{
			return _ThreadInfo.GetPublicInfo()
		}

		function GetThreadID()
		{
			if(_Thread == null)
			{
				if(_Parent == null)
				{
					return -1
				}
				return _Parent.GetThreadID()
			}
			return _Thread.ThreadID
		}
		

		function IsAlive()
		{
			if(_ForceDead)
			{
				return false
			}
			if(_Thread == null)
			{
				return true
			}
			return _Thread.IsAlive
		}

		function SetDead()
		{
			_ForceDead = true
		}
		function ToString()
		{
			state = "DEAD"
			if(IsAlive())
			{
				state = "ALIVE"
			}
			active = "INACTIVE"
			if(IsActive())
			{
				active = "ACTIVE"
			}
			state = $"{state}:{active}"
			return $"[PID_{_ThreadInfo.PID}] [{_ThreadInfo.User.GetName()}] [{state}] {_ThreadInfo.Name}"
		}

		function Abort()
		{
			if(_Thread != null)
			{
				_Thread.Abort()
			}
			else
			{
				SetDead()
			}
		}
		function Interrupt()
		{
			if(_Thread != null)
			{
				_Thread.Interrupt()
			}
			else
			{				
				SetDead()
			}
		}
		function InnerDelete()
		{
			_ThreadInfo.PID = -1
			_Children.Clear()
			_Parent = null
			_Thread = null
		}

		function FindProcessInChildren(!pid)
		{
			#ASSERT_NUMBER(pid)
			for i = 0 while< _Children.Size()
			{
				child = _Children[i]
				p = child.FindProcess(pid)
				if(p != null)
				{
					return p
				}
			}
		}

		function FindAnyInChildren(!selector)
		{
			#ASSERT_FUNCTION(selector)
			for i = 0 while< _Children.Size()
			{
				child = _Children[i]
				p = child.FindAny(selector)
				if(p != null)
				{
					return p
				}
			}
		}
		function FindAllInChildren(!selector)
		{
			#ASSERT_FUNCTION(selector)

			list = []
			for i = 0 while< _Children.Size()
			{
				child = _Children[i]
				
				p = child.FindAll(selector)
				foreach proc in p
				{
					list.Add(proc)
				}
			}
			return list
		}

		function FindAny(selector)
		{
			#ASSERT_FUNCTION(selector)
			if(selector(this))
			{
				return this
			}
			else
			{
				return FindAnyInChildren(selector)
			}
		}


		function FindAll(selector)
		{
			#ASSERT_FUNCTION(selector)
			children = FindAllInChildren(selector)
			
			if(selector(this))
			{
				children.Insert(0, this)
			}
			return children
		}

		function FindProcess(!pid)
		{
			#ASSERT_NUMBER(pid)
			if(_ThreadInfo.PID == pid)
			{
				return this
			}
			else
			{
				return FindProcessInChildren(pid)
			}
		}

		function ReapChildren()
		{
			for i = 0 while< _Children.Size()
			{
				child = _Children[i]
				child.ReapChildren()

				if(!child.IsAlive())
				{
					child.TransferChildrenToParent()
					child.InnerDelete()
					_Children.RemoveAt(i)
					i -= 1
				}
			}
		}

		function TransferChildrenToParent()
		{
			if(_Parent != null)
			{
				foreach child in _Children
				{
					_Parent._Children.Add(child)
				}
			}
			_Children.Clear()
		}

		function WriteProcessMap(!iw)
		{
			iw.Write(ToString())
			iw.Increase()
			for i = 0 while< _Children.Size()
			{
				child = _Children[i]
				child.WriteProcessMap(iw)
			}
			iw.Decrease()
		}
	}
}