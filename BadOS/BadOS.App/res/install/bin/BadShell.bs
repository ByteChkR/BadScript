




































namespace BadShell.Runner
{
	class ShellCommand
	{
		function GetName()
		{
			Environment.Error($"ShellCommand '{GetType()}' does not implement 'GetName()'")
		}

		function GetHelp()
		{
			Environment.Error($"ShellCommand '{GetName()}' does not implement 'GetHelp()'")
		}

		function RunCommand()
		{
			Environment.Error($"ShellCommand '{GetName()}' does not implement 'RunCommand()'")
		}
	}
}
namespace BadShell.Runner
{
	class CustomAliasResolver
	{
		
		function Resolve(!target)
		{
			Environment.Error($"CustomAliasResolver '{GetType()}' does not implement 'Resolve(!target)'")
		}

		function CanResolve(!target)
		{
			Environment.Error($"CustomAliasResolver '{GetType()}' does not implement 'CanResolve(!target)'")
		}
	}
}
namespace BadShell.Runner
{
	class CommandRunner
	{
		Console = null
		__commands = []
		__aliasTable = []
		__customAliasResolvers = []
		__envs = {}
		function CommandRunner(!console)
		{
			Console = console
			AddEnv("SHELL_NAME", "BadShell")
			AddEnv("SHELL_PRINT_INPUT", false)
		}

		function AddAlias(!aliasKey, !aliasValue)
		{
			__aliasTable.Add({key = aliasKey, value = aliasValue})
		}

		function AddEnv(!key, value)
		{
			__envs[key] = value
		}

		function GetEnv(!key)
		{
			if(Collection.HasKey(__envs, key))
			{
				return __envs[key]
			}
			return null
		}

		function AddAlias(!aliasKey, !aliasValue)
		{
			__aliasTable.Add({key = aliasKey, value = aliasValue})
		}

		function RemoveAlias(!aliasKey)
		{
			for i = 0 while< __aliasTable.Size()
			{
				if(__aliasTable[i].key == aliasKey)
				{
					__aliasTable.RemoveAt(i)
				}
			}
		}

		function AddCustomAliasResolver(!aliasResolver)
		{
			__customAliasResolvers.Add(aliasResolver)
		}


		function AddCommand(!cmd)
		{
			__commands.Add(cmd)
		}

		function ResolveTarget(!target)
		{
			foundAlias = true
			while(foundAlias)
			{
				foundAlias = false
				foreach resolver in __customAliasResolvers
				{
					if(resolver.CanResolve(target))
					{
						resolver.Resolve(target)
						foundAlias = true
						break
					}
				}
				if(foundAlias)
				{
					continue
				}
				foreach alias in __aliasTable
				{

					if(target.Target == alias.key)
					{
						target.Target = alias.value
						foundAlias = true
						break
					}
				}
			}
			
			return target
		}

		function FindTarget(!target)
		{
			t = ResolveTarget(target)
			foreach cmd in __commands
			{
				if(cmd.GetName() == t.Target)
				{
					return cmd
				}
			}
			return null
		}

		function CreateInput(!parsedCommand, !envs)
		{
			vals = parsedCommand.GetResolvedValues(__envs)
			target = vals[0]
			vals.RemoveAt(0)
			return {
				Target = target,
				Args = vals
			}
		}

		function PrintInputCommand(!cmd)
		{
			printInput = GetEnv("SHELL_PRINT_INPUT")
			if(printInput != null)
			{
				if(Convert.IsBoolean(printInput))
				{
					if(printInput)
					{
						Console.WriteLine($"Input: '{cmd.ToString()}'")
					}
				}
			}
		}

		function Run(!parsedCommand, ?envs)
		{
			PrintInputCommand(parsedCommand)
			if(envs == null)
			{
				envs = __envs
			}
			input = CreateInput(parsedCommand, envs)
			target = FindTarget(input)
			if(target != null)
			{
				target.RunCommand.Invoke(input.Args)
			}
			else
			{
				Console.WriteLine($"Unknown Command: '{input.Target}'")
			}
		}
	}
}
namespace BadShell.Parser.Expressions
{
	class Scope
	{
		__Parent = null
		__LocalVars = {}
		__ReturnFlag = false
		__ReturnValue = null
		__ScopeHooks = []

		function AddNamedHook(name, fnc)
		{
			
	
	if(name == null)
	{
		Environment.Error("Assertion Failed. name is NULL.")
	}

	if(!Convert.IsString(name))
	{
		Environment.Error("Assertion Failed. name is not a string. Actual Value: " + Environment.Debug(name))
	}

			AddScopeHook(function(n)
						{
							if(n == name)
							{
								return fnc
							}
							return null
						}
			)
		}

		function AddScopeHook(fnc)
		{
			__ScopeHooks.Add(fnc)
		}

		function GetFromHooks(name)
		{
			
	
	if(name == null)
	{
		Environment.Error("Assertion Failed. name is NULL.")
	}

	if(!Convert.IsString(name))
	{
		Environment.Error("Assertion Failed. name is not a string. Actual Value: " + Environment.Debug(name))
	}

			foreach hook in __ScopeHooks
			{
				v = hook(name)
				if(v != null)
				{
					return v
				}
			}

			if(__Parent != null)
			{
				return __Parent.GetFromHooks(name)
			}

			return null
		}

		function IsReturn() => return __ReturnFlag
		function GetReturn() => return __ReturnValue
		function SetReturn(value)
		{
			__ReturnValue = value
			__ReturnFlag = true
		}

		function Scope(?parent)
		{
			if(parent != null)
			{
				
	
	
	if(parent == null)
	{
		Environment.Error("Assertion Failed. parent is NULL.")
	}

	if(!Convert.IsType(parent))
	{
		Environment.Error("Assertion Failed. parent is not a Type. Actual Value: " + Environment.Debug(parent))
	}

	if(!parent.IsInstanceOf("Scope"))
	{
		Environment.Error("Assertion Failed. parent is not an Instance of Scope. Actual Value: " + Environment.Debug(parent))
	}

			}
			__Parent = parent

			AddNamedHook("set", Set)
			AddNamedHook("alias", AddNamedHook)
		}

		function CreateSubScope()
		{
			return new Scope(this)
		}

		function AddLocal(name, value)
		{
			
	
	if(name == null)
	{
		Environment.Error("Assertion Failed. name is NULL.")
	}

	if(!Convert.IsString(name))
	{
		Environment.Error("Assertion Failed. name is not a string. Actual Value: " + Environment.Debug(name))
	}

			if(value != null)
			{
				__LocalVars[name] = value
			}
		}

		function HasLocal(name)
		{
			
	
	if(name == null)
	{
		Environment.Error("Assertion Failed. name is NULL.")
	}

	if(!Convert.IsString(name))
	{
		Environment.Error("Assertion Failed. name is not a string. Actual Value: " + Environment.Debug(name))
	}

			return Collection.HasKey(__LocalVars, name)
		}

		function Has(name)
		{
			
	
	if(name == null)
	{
		Environment.Error("Assertion Failed. name is NULL.")
	}

	if(!Convert.IsString(name))
	{
		Environment.Error("Assertion Failed. name is not a string. Actual Value: " + Environment.Debug(name))
	}

			if(HasLocal(name))
			{
				return true
			}
			else if(__Parent != null)
			{
				return __Parent.Has(name)
			}
			return false
		}

		function Get(name)
		{
			
	
	if(name == null)
	{
		Environment.Error("Assertion Failed. name is NULL.")
	}

	if(!Convert.IsString(name))
	{
		Environment.Error("Assertion Failed. name is not a string. Actual Value: " + Environment.Debug(name))
	}


			if(HasLocal(name))
			{
				return __LocalVars[name]
			}
			else if(__Parent != null)
			{
				return __Parent.Get(name)
			}
			Environment.Error($"Can not find Variable: {name} in {Environment.Debug(this)}")
			return null
		}

		function SetIfExists(name, value)
		{
			
	
	if(name == null)
	{
		Environment.Error("Assertion Failed. name is NULL.")
	}

	if(!Convert.IsString(name))
	{
		Environment.Error("Assertion Failed. name is not a string. Actual Value: " + Environment.Debug(name))
	}

			if(HasLocal(name))
			{
				AddLocal(name, value)
				return true
			}
			else if(__Parent != null)
			{
				return SetIfExists(name, value)
			}
			return false
		}

		function Set(name, value)
		{
			
	
	if(name == null)
	{
		Environment.Error("Assertion Failed. name is NULL.")
	}

	if(!Convert.IsString(name))
	{
		Environment.Error("Assertion Failed. name is not a string. Actual Value: " + Environment.Debug(name))
	}

			if(__Parent == null)
			{
				AddLocal(name, value)
			}
			else if(!__Parent.SetIfExists(name, value))
			{
				AddLocal(name, value)
			}
		}
	}

	class Expression
	{
		function Compute(scope)
		{
			
	
	
	if(scope == null)
	{
		Environment.Error("Assertion Failed. scope is NULL.")
	}

	if(!Convert.IsType(scope))
	{
		Environment.Error("Assertion Failed. scope is not a Type. Actual Value: " + Environment.Debug(scope))
	}

	if(!scope.IsInstanceOf("Scope"))
	{
		Environment.Error("Assertion Failed. scope is not an Instance of Scope. Actual Value: " + Environment.Debug(scope))
	}

		}
	}

	class StaticExpression : Expression
	{
		__value = null
		function StaticExpression(value)
		{
			__value = value
		}

		function Compute(scope) : base(scope)
		{
			return __value
		}

		function ToString()
		{
			return $"{__value}"
		}
	}


	class WordExpression : Expression
	{
		__value = null
		function WordExpression(value)
		{
			__value = value
		}

		function Compute(scope) : base(scope)
		{
			v = scope.GetFromHooks(__value)
			lastV = v
			while(v != null)
			{
				lastV = v
				if(!Convert.IsString(v))
				{
					break
				}
				v = scope.GetFromHooks(v)
			}
			if(lastV != null)
			{
				return lastV
			}
			return __value
		}

		function ToString()
		{
			return $"({__value})"
		}
	}

	class VariableExpression : Expression
	{
		__name = null
		function VariableExpression(name)
		{
			__name = name
		}

		function Compute(scope) : base(scope)
		{
			return scope.Get(__name)
		}

		function ToString()
		{
			return $"$[{__name}]"
		}
	}

	class InvokeExpression : Expression
	{
		__target = null
		__parameters = null
		function InvokeExpression(!target, ?parameters)
		{
			
	
	
	if(target == null)
	{
		Environment.Error("Assertion Failed. target is NULL.")
	}

	if(!Convert.IsType(target))
	{
		Environment.Error("Assertion Failed. target is not a Type. Actual Value: " + Environment.Debug(target))
	}

	if(!target.IsInstanceOf("Expression"))
	{
		Environment.Error("Assertion Failed. target is not an Instance of Expression. Actual Value: " + Environment.Debug(target))
	}

			__target = target
			if(parameters == null)
			{
				__parameters = []
			}
			else
			{
				
	
	if(parameters == null)
	{
		Environment.Error("Assertion Failed. parameters is NULL.")
	}

	if(!Convert.IsArray(parameters))
	{
		Environment.Error("Assertion Failed. parameters is not an Array. Actual Value: " + Environment.Debug(parameters))
	}

				__parameters = parameters
			}
		}

		function Compute(scope) : base(scope)
		{
			target = __target.Compute(scope)

			args = []
			foreach param in __parameters
			{
				args.Add(param.Compute(scope))
			}

			if(target == null)
			{
				return null
			}

			if(!Convert.IsFunction(target))
			{
				Environment.Error($"Can not Resolve '{__target.ToString()}' current value '{target}' in scope {Environment.Debug(scope)}")
			}

			return target.Invoke(args)
		}

		function ToString()
		{
			s = $"$({__target.ToString()}"
			foreach param in __parameters
			{
				s += $" {param.ToString()}"
			}
			s += ")"
			return s
		}
	}

	class BlockExpression : Expression
	{
		__block = null
		function BlockExpression(!block)
		{
			
	
	if(block == null)
	{
		Environment.Error("Assertion Failed. block is NULL.")
	}

	if(!Convert.IsArray(block))
	{
		Environment.Error("Assertion Failed. block is not an Array. Actual Value: " + Environment.Debug(block))
	}

			__block = block
		}

		function Compute(scope) : base(scope)
		{
			foreach expr in __block
			{
				expr.Compute(scope)
				if(scope.IsReturn())
				{
					return null
				}
			}
			return null
		}

		function ToString()
		{
			s = "{\n"
			foreach param in __block
			{
				s += $"\t {param.ToString()}\n"
			}
			s += "}"
			return s
		}
	}

	class ScopedExpression : Expression
	{
		__expr = null
		function ScopedExpression(!expr)
		{
		}

		function Compute(scope) : base(scope)
		{
			
	
	
	if(scope == null)
	{
		Environment.Error("Assertion Failed. scope is NULL.")
	}

	if(!Convert.IsType(scope))
	{
		Environment.Error("Assertion Failed. scope is not a Type. Actual Value: " + Environment.Debug(scope))
	}

	if(!scope.IsInstanceOf("Scope"))
	{
		Environment.Error("Assertion Failed. scope is not an Instance of Scope. Actual Value: " + Environment.Debug(scope))
	}

			blockScope = scope.CreateSubScope()

			__expr.Compute(blockScope)

			if(blockScope.IsReturn())
			{
				return blockScope.GetReturn()
			}
			return null
		}
		function ToString()
		{
			return $"@{__expr.ToString()}"
		}
	}

	class IfExpression : Expression
	{
		__condition = null
		__trueExpr = null
		__falseExpr = null
		function IfExpression(!condition, !trueExpr, ?falseExpr)
		{
			__condition = condition
			__trueExpr = trueExpr
			__falseExpr = falseExpr
		}

		function Compute(scope)
		{
			expr = null
			if(__condition.Compute(scope))
			{
				expr = __trueExpr
			}
			else
			{
				expr = __falseExpr
			}

			if(expr != null)
			{
				expr.Compute(scope)
			}
		}

		function ToString()
		{
			if(__falseExpr != null)
			{
				return $"if({__condition.ToString()}) {__trueExpr.ToString()} else {__falseExpr.ToString()}"
			}

			return $"if({__condition.ToString()}) {__trueExpr.ToString()}"
		}
	}



	class ExpressionReader
	{
		Console = null
		__src = null
		__current = 0
		function ExpressionReader(!console, !src)
		{
			Console = console
			__src = src
		}

		function IsEOF(?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			return String.Length(__src) <= __current + off
		}

		function Is(!c, ?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			return String.CharAt(__src, __current+off) == c
		}

		function IsWhiteSpace(?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			c = String.CharAt(__src, __current+off)
			return String.IsWhiteSpace(c) && c != "\n"
		}

		function IsWordChar(?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			return IsLetter(off) || Is("_", off) || Is("\\", off) || Is("/", off) || Is("-", off) || Is(".", off)
		}

		function IsLetter(?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			return String.IsLetter(String.CharAt(__src, __current+off))
		}

		function IsDigit(?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			return String.IsDigit(String.CharAt(__src, __current+ off))
		}

		function Get()
		{
			return String.CharAt(__src, __current)
		}

		function Eat(!c)
		{
			if(!Is(c))
			{
				Environment.Error($"Expected {c} but got {Get()}")
			}
			__current += 1
			return c
		}

		function MoveNext()
		{
			return Eat(Get())
		}

		function EatWhiteSpace()
		{
			while(IsWhiteSpace())
			{
				MoveNext()
				if(IsEOF())
				{
					break
				}
			}
		}

		function ParseWord()
		{
			EatWhiteSpace()

			if(IsEOF())
			{
				Environment.Error($"Expected Word Begin but got EOF")
			}
			if(!IsWordChar())
			{
				Environment.Error($"Expected Word Begin but got {Get()}")
			}
			word = MoveNext()
			if(IsEOF())
			{
				return word
			}
			while(IsWordChar())
			{
				word += MoveNext()
				if(IsEOF())
				{
					break
				}
			}

			return word
		}

		function ParseVariable()
		{
			EatWhiteSpace()
			if(!Is("%"))
			{
				Environment.Error($"Expected % but got {Get()}")
			}

			MoveNext()
			str = ParseWord()
			EatWhiteSpace()
			if(!Is("%"))
			{
				Environment.Error($"Expected % but got {Get()}")
			}
			MoveNext()
			return str
		}

		function ParseNumber()
		{
			EatWhiteSpace()
			num = ""
			if(Is("-"))
			{
				num += MoveNext()
			}
			isFraction = false
			hasDecimalPlaces = false
			canBeFraction = true

			while(true)
			{
				if(IsEOF())
				{
					break
				}
				if(Is("."))
				{
					if(isFraction)
					{
						Environment.Error("Do many decimal Seperators")
					}
					isFraction =  true
				}
				else if(isFraction)
				{
					hasDecimalPlaces = true
				}
				if(!IsDigit() && !Is("."))
				{
					break
				}
				dig = IsDigit()
				c = MoveNext()
				num += c

				if(IsEOF())
				{
					break
				}
			}

			if(isFraction && !hasDecimalPlaces)
			{
				__current -= 1
				num = String.Remove(num, String.Length(num) - 1, 1)
			}
			Console.WriteLine("Parsed Number: " + num)
			return Convert.ToNumber(num)
		}

		function ParseString()
		{
			EatWhiteSpace()
			if(!Is("\""))
			{
				Environment.Error($"Expected Word Begin but got {Get()}")
			}
			MoveNext()
			str = ""
			isEscaped = false
			while(!Is("\""))
			{
				if(Is("\n"))
				{
					Environment.Error($"Missing '\"'")
				}
				else if(Is("\\"))
				{
					isEscaped = true
					MoveNext()
					escChar = MoveNext()
					str += String.RegexUnescape($"\\{escChar}")
				}
				else
				{
					str += MoveNext()
				}
				if(IsEOF())
				{
					break
				}
			}
			if(!IsEOF())
			{
				MoveNext()
			}
			return str
		}

		function ParseIfExpression()
		{
			cond = ParseValue()
			trueExpr = ParseValue()
			falseExpr = null
			if(IsEOF())
			{
				return new IfExpression(cond, trueExpr, falseExpr)
			}
			EatWhiteSpace()
			if(IsEOF())
			{
				return new IfExpression(cond, trueExpr, falseExpr)
			}
			if(IsWordChar())
			{
				pos = __current
				word = ParseWord()
				if(word == "else")
				{
					falseExpr = ParseValue()
				}
				else
				{
					__current = pos
				}
			}
			return new IfExpression(cond, trueExpr, falseExpr)
		}

		function ParseValue()
		{
			EatWhiteSpace()
			if(Is("$"))
			{
				return ParseSubCommand()
			}
			if(Is("{"))
			{
				return ParseBlock()
			}
			if(Is("\""))
			{
				str = ParseString()
				return new StaticExpression(str)
			}
			if(Is("%"))
			{
				var = ParseVariable()
				return new VariableExpression(var)
			}
			if(IsDigit() || (Is("-") && !IsEOF(1)))
			{
				if(Is("-") && !IsWordChar(1))
				{
					num = ParseNumber()
					return new StaticExpression(num)
				}
				else if(IsDigit())
				{
					num = ParseNumber()
					return new StaticExpression(num)
				}
			}
			if(IsWordChar())
			{
				word = ParseWord()
				if(	String.ToLower(word) == "false")
				{
					return new StaticExpression(false)
				}

				if(	String.ToLower(word) == "true")
				{
					return new StaticExpression(true)
				}

				if(word == "if")
				{
					return ParseIfExpression()
				}

				return new WordExpression(word)
			}

			Environment.Error($"Can not Parse: {Get()}")
		}

		function ParseSubCommand()
		{
			EatWhiteSpace()
			cmds = []
			Eat("$")
			Eat("(")
			while(!Is(")"))
			{
				if(IsEOF())
				{
					break
				}
				cmds.Add(ParseValue())
				if(IsEOF())
				{
					break
				}
				EatWhiteSpace()
				if(IsEOF())
				{
					break
				}
			}
			Eat(")")
			target = cmds[0]
			cmds.RemoveAt(0)
			cmd = new InvokeExpression(target, cmds)
			return cmd
		}

		function ParseCommand()
		{
			EatWhiteSpace()
			cmds = []

			while(!Is("\n"))
			{
				if(IsEOF())
				{
					break
				}
				cmds.Add(ParseValue())
				if(IsEOF())
				{
					break
				}
				EatWhiteSpace()
				if(IsEOF())
				{
					break
				}
			}
			target = cmds[0]
			cmds.RemoveAt(0)
			cmd = new InvokeExpression(target, cmds)
			return cmd
		}

		function ParseBlock()
		{
			if(!Is("{"))
			{
				Environment.Error("Expected '{'")
			}
			Eat("{")
			EatWhiteSpace()
			cmds = []
			while(!IsEOF())
			{
				EatWhiteSpace()
				while(Is("\n"))
				{
					MoveNext()
					if(IsEOF())
					{
						break
					}
					EatWhiteSpace()
				}
				if(IsEOF())
				{
					break
				}

				if(Is("}"))
				{
					break
				}
				cmds.Add(ParseCommand())
			}

			if(!Is("}"))
			{
				Environment.Error("Expected '{'")
			}
			Eat("}")

			return new BlockExpression(cmds)
		}

		function ParseToEnd()
		{
			EatWhiteSpace()
			cmds = []
			while(!IsEOF())
			{
				EatWhiteSpace()
				while(Is("\n"))
				{
					MoveNext()
					if(IsEOF())
					{
						break
					}
					EatWhiteSpace()
				}
				if(IsEOF())
				{
					break
				}
				cmds.Add(ParseCommand())
				
			}

			return new BlockExpression(cmds)
		}
	}

	class ShellTest
	{
		__scope = null
		__runner = null
		Console = null
		function ShellTest(!console, ?scope)
		{
			Console = console
			if(scope == null)
			{
				scope = new Scope()
			}
			
	
	
	if(scope == null)
	{
		Environment.Error("Assertion Failed. scope is NULL.")
	}

	if(!Convert.IsType(scope))
	{
		Environment.Error("Assertion Failed. scope is not a Type. Actual Value: " + Environment.Debug(scope))
	}

	if(!scope.IsInstanceOf("Scope"))
	{
		Environment.Error("Assertion Failed. scope is not an Instance of Scope. Actual Value: " + Environment.Debug(scope))
	}

			__scope = scope
			__runner = new ExpressionRunner(Console)
		}

		function GetRootScope() => return __scope

		function RunScript(src)
		{
			return __runner.RunScript(src, __scope.CreateSubScope())
		}
		function RunRootScript(src)
		{
			return __runner.RunScript(src, __scope)
		}
	}

	class ExpressionRunner
	{
		Console = null

		function ExpressionRunner(!console)
		{
			Console = console
		}

		function RunScript(src, ?scope)
		{
			return Run(Parse(src), scope)
		}

		function Parse(src)
		{
			
	
	if(src == null)
	{
		Environment.Error("Assertion Failed. src is NULL.")
	}

	if(!Convert.IsString(src))
	{
		Environment.Error("Assertion Failed. src is not a string. Actual Value: " + Environment.Debug(src))
	}

			reader = new ExpressionReader(Console, src)
			expr = reader.ParseToEnd()
			return expr
		}

		function Run(expr, ?scope)
		{
			if(scope == null)
			{
				scope = new Scope()
			}

			
	
	
	if(scope == null)
	{
		Environment.Error("Assertion Failed. scope is NULL.")
	}

	if(!Convert.IsType(scope))
	{
		Environment.Error("Assertion Failed. scope is not a Type. Actual Value: " + Environment.Debug(scope))
	}

	if(!scope.IsInstanceOf("Scope"))
	{
		Environment.Error("Assertion Failed. scope is not an Instance of Scope. Actual Value: " + Environment.Debug(scope))
	}

			return expr.Compute(scope)
		}
	}
}
namespace BadShell.Parser
{


	class ParserCommand
	{
		__values = null
		function ParserCommand( values)
		{
			__values = values
		}

		function GetResolvedValues(!envs)
		{
			v = []
			foreach value in __values
			{
				v.Add(value.GetValue(envs))
			}
			return v
		}

		function ToString()
		{
			s = ""
			first = true
			foreach value in __values
			{
				if(first)
				{
					first = false
				}
				else
				{
					s += " "
				}
				s += value.ToString()
			}
			return s
		}
	}

	class ParserValue
	{
		function GetValue(!envs)
		{
			Environment.Error($"{GetType()} does not implement GetValue(!envs)")
		}

	}

	class ParserStringValue : ParserValue
	{
		__value = null
		function ParserStringValue(!value)
		{
			__value = value
		}

		function GetValue(!envs)
		{
			return __value
		}
		function ToString()
		{
			return $"\"{__value}\""
		}
	}

	class ParserWordValue : ParserValue
	{
		__word = null
		function ParserWordValue(!word)
		{
			__word = word
		}

		function GetValue(!envs)
		{
			return __word
		}

		function ToString()
		{
			return __word
		}
	}

	class ParserNumberValue : ParserValue
	{

		__value = null
		function ParserNumberValue(!value)
		{
			__value = value
		}
		
		function GetValue(!envs)
		{
			return Convert.ToNumber(__value)
		}


		function ToString()
		{
			return __value
		}
	}


	class ParserBooleanValue : ParserValue
	{

		__value = null
		function ParserBooleanValue(!value)
		{
			__value = value
		}
		
		function GetValue(!envs)
		{
			return Convert.ToBoolean(__value)
		}

		function ToString()
		{
			return __value
		}
	}

	class ParserEnvironmentVariable : ParserValue
	{
		__varName = null
		function ParserEnvironmentVariable(!varName)
		{
			__varName = varName
		}
		
		function GetValue(!envs)
		{
			return envs[__varName]
		}

		
		function ToString()
		{
			return $"%{__varName}%"
		}
	}

	class CommandReader
	{
		Console = null
		__src = null
		__current = 0
		function CommandReader(!console, !src)
		{
			Console = console
			__src = src
		}

		function IsEOF(?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			return String.Length(__src) <= __current + off
		}

		function Is(!c, ?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			return String.CharAt(__src, __current+off) == c
		}

		function IsWhiteSpace(?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			c = String.CharAt(__src, __current+off)
			return String.IsWhiteSpace(c) && c != "\n"
		}

		function IsWordChar(?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			return IsLetter(off) || Is("_", off) || Is("\\", off) || Is("/", off) || Is("-", off) || Is(".", off)
		}

		function IsLetter(?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			return String.IsLetter(String.CharAt(__src, __current+off))
		}

		function IsDigit(?off)
		{
			if(off == null)
			{
				off = 0
			}
			
	
	if(off == null)
	{
		Environment.Error("Assertion Failed. off is NULL.")
	}

	if(!Convert.IsNumber(off))
	{
		Environment.Error("Assertion Failed. off is not a number. Actual Value: " + Environment.Debug(off))
	}

			return String.IsDigit(String.CharAt(__src, __current+ off))
		}

		function Get()
		{
			return String.CharAt(__src, __current)
		}

		function Eat(!c)
		{
			if(!Is(c))
			{
				Environment.Error($"Expected {c} but got {Get()}")
			}
			__current += 1
			return c
		}

		function MoveNext()
		{
			return Eat(Get())
		}

		function EatWhiteSpace()
		{
			while(IsWhiteSpace())
			{
				MoveNext()
				if(IsEOF())
				{
					break
				}
			}
		}

		function ParseWord()
		{
			EatWhiteSpace()

			if(IsEOF())
			{
				Environment.Error($"Expected Word Begin but got EOF")
			}
			if(!IsWordChar())
			{
				Environment.Error($"Expected Word Begin but got {Get()}")
			}
			word = MoveNext()
			if(IsEOF())
			{
				return word
			}
			while(IsWordChar())
			{
				word += MoveNext()
				if(IsEOF())
				{
					break
				}
			}

			return word
		}

		function ParseVariable()
		{
			EatWhiteSpace()
			if(!Is("%"))
			{
				Environment.Error($"Expected % but got {Get()}")
			}

			MoveNext()
			str = ParseWord()
			EatWhiteSpace()
			if(!Is("%"))
			{
				Environment.Error($"Expected % but got {Get()}")
			}
			MoveNext()
			return str
		}

		function ParseNumber()
		{
			num = ""
			if(Is("-"))
			{
				num += MoveNext()
			}
			isFraction = false
			hasDecimalPlaces = false
			while(IsDigit() || (!isFraction && Is(".")))
			{
				if(IsEOF())
				{
					break
				}
				if(Is("."))
				{
					isFraction =  true
				}
				else if(isFraction)
				{
					hasDecimalPlaces = true
				}
				num += MoveNext()

				if(IsEOF())
				{
					break
				}
			}

			if(isFraction && !hasDecimalPlaces)
			{
				__current -= 1
				num = String.Remove(num, String.Length(num) - 1, 1)
			}
			Console.WriteLine("Parsed Number: " + num)
			return num
		}

		function ParseString()
		{
			EatWhiteSpace()
			if(!Is("\""))
			{
				Environment.Error($"Expected Word Begin but got {Get()}")
			}
			MoveNext()
			str = ""
			isEscaped = false
			while(!Is("\""))
			{
				if(Is("\n"))
				{
					Environment.Error($"Missing '\"'")
				}
				else if(Is("\\"))
				{
					isEscaped = true
					MoveNext()
					escChar = MoveNext()
					str += String.RegexUnescape($"\\{escChar}")
				}
				else
				{
					str += MoveNext()
				}
				if(IsEOF())
				{
					break
				}
			}
			if(!IsEOF())
			{
				MoveNext()
			}
			return str
		}

		function ParseValue()
		{
			EatWhiteSpace()
			if(Is("\""))
			{
				str = ParseString()
				return new ParserStringValue(str)
			}
			if(Is("%"))
			{
				var = ParseVariable()
				return new ParserEnvironmentVariable(var)
			}
			if(IsDigit() || (Is("-") && !IsEOF(1)))
			{
				if(Is("-") && !IsWordChar(1))
				{
					num = ParseNumber()
					return new ParserNumberValue(num)
				}
			}
			if(IsWordChar())
			{
				word = ParseWord()
				if(	String.ToLower(word) == "true" ||
					String.ToLower(word) == "false")
				{
					return new ParserBooleanValue(word)
				}

				return new ParserWordValue(word)
			}

			Environment.Error($"Can not Parse: {Get()}")
		}

		function ParseCommand()
		{
			EatWhiteSpace()
			cmds = []

			while(!Is("\n"))
			{
				if(IsEOF())
				{
					break
				}
				cmds.Add(ParseValue())
				if(IsEOF())
				{
					break
				}
				EatWhiteSpace()
				if(IsEOF())
				{
					break
				}
			}
			cmd = new ParserCommand(cmds)
			return cmd
		}

		function ParseToEnd()
		{
			EatWhiteSpace()
			cmds = []
			while(!IsEOF())
			{
				EatWhiteSpace()
				while(Is("\n"))
				{
					MoveNext()
					if(IsEOF())
					{
						break
					}
					EatWhiteSpace()
				}
				if(IsEOF())
				{
					break
				}
				cmds.Add(ParseCommand())
				
			}

			return cmds
		}
	}
}
namespace BadShell.Parser
{

	class CommandParser
	{
		Console = null
		function CommandParser(!console)
		{
			Console = console
		}
		function ParseCommands(!src)
		{
			reader = new CommandReader(Console, src)
			try
			{
				cmds = reader.ParseToEnd()
				return cmds
			}
			catch(e)
			{
				Console.WriteLine($"Can not Parse Source: '{src}'")
				Environment.Rethrow(e)
			}
			return null
		}
	}
}
namespace BadShell.Commands
{
	class RunShellScriptCustomAliasResolver : CustomAliasResolver
	{
		FileSystem = null
		Console = null
		ProcessInfo = null
		function RunShellScriptCustomAliasResolver(!fileSystem, !console, !pinfo)
		{
			FileSystem = fileSystem
			Console = console
			ProcessInfo = pinfo
		}

		function Resolve(!target)
		{
			target.Args.Insert(0, target.Target)
			target.Target = "bsh"
		}

		function CanResolve(!target)
		{
			if(FileSystem.Exists(FileSystem.GetRootNode(), ProcessInfo.ResolvePath(target.Target)) && String.EndsWith(target.Target, ".bsh"))
			{
				return true
			}
			return false
		}
	}

	class RunShellScriptCommand : ShellCommand
	{
		FileSystem = null
		__runner = null
		__parser = null
		__user = null
		function RunShellScriptCommand(!user, !parser, !runner, !fileSystem)
		{
			__user = user
			__parser = parser
			__runner = runner
			FileSystem = fileSystem
		}
		function GetName()
		{
			return "bsh"
		}

		function GetHelp()
		{
			return "Runs a BadShell Script"
		}

		function RunCommand(!file)
		{
			src = FileSystem.FindNode(FileSystem.GetRootNode(), file).ReadAllText(__user)
			cmds = __parser.ParseCommands(src)
			foreach cmd in cmds
			{
				__runner.Run(cmd)
			}
		}
	}
}
namespace BadShell.Commands
{
	class RunScriptCustomAliasResolver : CustomAliasResolver
	{
		FileSystem = null
		Console = null
		ProcessInfo = null
		function RunScriptCustomAliasResolver(!fileSystem, !console, !pinfo)
		{
			FileSystem = fileSystem
			Console = console
			ProcessInfo = pinfo
		}

		function Resolve(!target)
		{
			target.Args.Insert(0, target.Target)
			target.Target = "bs"
		}

		function CanResolve(!target)
		{
			if(FileSystem.Exists(FileSystem.GetRootNode(), ProcessInfo.ResolvePath(target.Target)) && String.EndsWith(target.Target, ".bs"))
			{
				return true
			}
			return false
		}
	}

	class RunScriptCommand : ShellCommand
	{
		FileSystem = null
		Concurrency = null
		ProcessInfo = null
		Logger = null
		function RunScriptCommand(!pinfo ,!fileSystem, !concurrencySystem, !logger)
		{
			FileSystem = fileSystem
			Concurrency = concurrencySystem
			ProcessInfo = pinfo
			Logger = logger
		}
		function GetName()
		{
			return "bs"
		}

		function GetHelp()
		{
			return "Runs a BadScript File"
		}

		function RunCommand(*args)
		{
			if(args.Size() == 0)
			{
				return null
			}
			user = ProcessInfo.GetUser()
			file = args[0]
			file = ProcessInfo.ResolvePath(file)
			node = FileSystem.FindNode(FileSystem.GetRootNode(), file)
			if(node.IsFile())
			{
				src = node.ReadAllText(user)
				proc = Concurrency.StartSynchronousProcess(user, src, args, ProcessInfo.GetWorkingDirectory(), file)
			}
			else
			{
				Environment.Error($"{file} is not a File")
			}
			return null
		}
	}
}
namespace BadShell.Commands
{
	using BadShell.Runner
	class HelpCommand : ShellCommand
	{
		__runner = null
		__parser = null

		Console = null
		function HelpCommand(!console, !parser, !runner)
		{
			Console = console
			__runner = runner
			__parser = parser
		}

		function GetName()
		{
			return "help"
		}

		function GetHelp()
		{
			return "Prints this help Text"
		}

		function ConstructCommandText(!cmd)
		{
			return $"{cmd.GetName()}: {cmd.GetHelp()}"
		}

		function ConstructCommandTexts(!cmds)
		{
			r = "Commands:\n"
			foreach cmd in cmds
			{
				r+= $"\t- {ConstructCommandText(cmd)}\n"
			}
			return r
		}

		function RunCommand(?cmdName)
		{
			if(cmdName == null)
			{
				Console.WriteLine(ConstructCommandTexts(__runner.__commands))
			}
			else
			{
				input = __parser.ParseCommand(cmdName)
				if(input == null)
				{
					Console.WriteLine($"Can not parse Command: {cmdName}")
				}
				else
				{
					cmd = __runner.FindTarget(input)
					if(cmd == null)
					{
						Console.WriteLine($"Can not find Command: {cmdName}")
					}
					else
					{
						Console.WriteLine(ConstructCommandText(cmd))
					}
				}
			}
		}
	}
}
namespace BadShell.Commands
{
	class ExitCommand: ShellCommand
	{
		_fnc = null
		function ExitCommand(!fnc)
		{
			_fnc = fnc
		}
		function GetName()
		{
			return "exit"
		}

		function GetHelp()
		{
			return "Exits the current Shell Session"
		}

		function RunCommand()
		{
			_fnc()
		}
	}
}
namespace BadShell.Commands
{
	class EnvironmentVariableCommand : ShellCommand
	{
		__runner = null
		Console = null
		function EnvironmentVariableCommand(!console, !runner)
		{
			Console = console
			__runner = runner
		}
		function GetName()
		{
			return "env"
		}

		function GetHelp()
		{
			return "'set'/'get'/'list' Environment Variables"
		}

		function RunCommand(?operation, ?key, ?value)
		{
			if(operation == "set")
			{
				if(key == null)
				{
					Console.WriteLine("Expected key and optional value as arguments.")
				}
				else
				{
					__runner.AddEnv(key, value)
				}
			}
			else if(operation == "get")
			{
				if(key == null)
				{
					Console.WriteLine("Expected key as argument.")
				}
				else if(value != null)
				{
					Console.WriteLine("Expected no value argument.")
				}
				else
				{
					Console.WriteLine($"Value of '{key}': {__runner.GetEnv(key)}")
				}
			}
			else if(operation == "list")
			{
				if(key != null || value != null)
				{
					Console.WriteLine("Expected no arguments.")
				}
				else
				{
					Console.WriteLine("Environment Variables:")
					foreach (k, v) in __runner.__envs
					{
						Console.WriteLine($"\t- {k}: {v}")
					}
				}
			}
			else if(operation == null)
			{
				Console.WriteLine($"No Environment Variable Operation specified")
			}
			else
			{
				Console.WriteLine($"Unknown Environment Variable Operation: '{operation}'")
			}
		}
	}
}
namespace BadShell.Commands
{
	class EchoCommand: ShellCommand
	{
		Console = null
		function EchoCommand(!console)
		{
			Console = console
		}
		function GetName()
		{
			return "echo"
		}

		function GetHelp()
		{
			return "Writes the Input back to the console output"
		}

		function RunCommand(*args)
		{
			l = ""
			for i = 0 while< args.Size()
			{
				if(i != 0)
				{
					l += " "
				}
				l += $"{args[i]}"
			}
			Console.WriteLine(l)
		}
	}
}
namespace BadShell.Commands
{
	class ClearConsoleCommand: ShellCommand
	{
		Console = null
		function ClearConsoleCommand(!console)
		{
			Console = console
		}
		function GetName()
		{
			return "clear"
		}

		function GetHelp()
		{
			return "Clears the Console Output"
		}

		function RunCommand()
		{
			Console.Clear()
		}
	}
}
namespace BadShell.Commands
{
	class ChangeDirectoryCommand: ShellCommand
	{
		FileSystem = null
		ProcessInfo = null
		Logger = null
		function ChangeDirectoryCommand(!processInfo, !fileSystem, !logger)
		{
			ProcessInfo = processInfo
			FileSystem = fileSystem
			Logger = logger
		}
		function GetName()
		{
			return "cd"
		}

		function GetHelp()
		{
			return "Changes the current working directory"
		}

		function RunCommand(!dir)
		{	
			fullPath = FileSystem.ResolvePath(dir, ProcessInfo.GetWorkingDirectory())
			
			if(FileSystem.Exists(FileSystem.GetRootNode(), fullPath))
			{
				node = FileSystem.FindNode(FileSystem.GetRootNode(), fullPath)
				ProcessInfo.SetWorkingDirectory(node.GetFullName())
			}
			else
			{
				Logger.Warn($"Can not Find Path: {fullPath}")
			}
		}
	}
}
namespace BadShell.Commands
{
	using BadShell.Runner
	class AliasCommand : ShellCommand
	{
		__runner = null
		Console = null
		function AliasCommand(!console, !runner)
		{
			Console = console
			__runner = runner
		}

		function GetName()
		{
			return "alias"
		}

		function GetHelp()
		{
			return "'add'/'remove'/'list' aliases."
		}

		
		function RunCommand(?operation, ?key, ?value)
		{
			if(operation == "add")
			{
				if(key == null || value == null)
				{
					Console.WriteLine("Expected key and value as arguments.")
				}
				else
				{
					__runner.AddAlias(key, value)
				}
			}
			else if(operation == "remove")
			{
				if(key == null)
				{
					Console.WriteLine("Expected key as argument.")
				}
				else if(value != null)
				{
					Console.WriteLine("Expected no value argument.")
				}
				else
				{
					__runner.RemoveAlias(key)
				}
			}
			else if(operation == "list")
			{
				if(key != null || value != null)
				{
					Console.WriteLine("Expected no arguments.")
				}
				else
				{
					Console.WriteLine("Aliases:")
					foreach alias in __runner.__aliasTable
					{
						Console.WriteLine($"\t- {alias.key} => {alias.value}")
					}
				}
			}
			else if(operation == null)
			{
				Console.WriteLine($"No Alias Operation specified")
			}
			else
			{
				Console.WriteLine($"Unknown Alias Operation: '{operation}'")
			}
		}
	}
}
namespace BadShell
{


	class BadShellModule
	{
		ProcessInfo = null
		Console = null
		Extension = null

		__exited = false
		__shell = null


		__currentCommand = ""
		__firstUpdate = true

		function WritePrefix()
		{
			Console.Write($"{ProcessInfo.GetUser().GetName()}@{OS.GetMachineName()}: {ProcessInfo.GetWorkingDirectory()}$")
		}

		function OnUpdate()
		{
			if(__firstUpdate)
			{
				__firstUpdate = false
				WritePrefix()
			}

			while(true)
			{
				c = Console.ReadChar()
				if(c == "\0")
				{
					break
				}
				if(c == "\n" && __currentCommand != "")
				{
					__shell.RunScript(__currentCommand)
					__currentCommand = ""
					if(!__exited)
					{
						WritePrefix()
					}
					break
				}
				if(c != "\n" && c != "\r")
				{
					__currentCommand += c
				}
				else if(c == "\n")
				{
					WritePrefix()
				}
			}
		}

		function BadShellModule(!pinfo, !extensions, !startFiles, !exitFunc)
		{
			Extensions = extensions
			ProcessInfo = pinfo
			l = Extensions.GetExtension(ProcessInfo.GetUser(), "BadOS.Extensions.Logging")
			_logger = l.CreateLogger("BadShell")
			Console = Extensions.GetExtension(ProcessInfo.GetUser(), "BadOS.Extensions.Console")
			ConcurrencySystem = Extensions.GetExtension(ProcessInfo.GetUser(), "BadOS.Extensions.Concurrency")
			FileSystem = Extensions.GetExtension(ProcessInfo.GetUser(), "BadOS.Extensions.FileSystem")

			__shell = new ShellTest(Console)

			function RunProcess(file, args)
			{
				user = ProcessInfo.GetUser()
				file = ProcessInfo.ResolvePath(file)
				node = FileSystem.FindNode(FileSystem.GetRootNode(), file)
				if(node.IsFile())
				{
					src = node.ReadAllText(user)
					args.Insert(0, file)
					return ConcurrencySystem.StartSynchronousProcess(user, src, args, ProcessInfo.GetWorkingDirectory(), file)
				}
				else
				{
					Environment.Error($"{file} is not a File")
				}
				return null
			}

			function RunShellScript(!file)
			{
				if(FileSystem.Exists(FileSystem.GetRootNode(), file))
				{
					src = FileSystem.FindNode(FileSystem.GetRootNode(), file).ReadAllText(ProcessInfo.GetUser())
					return __shell.RunRootScript(src)
				}
				return null
			}

			function PathResolver(!path)
			{
				if(FileSystem.Exists(FileSystem.GetRootNode(), path))
				{
					node = FileSystem.FindNode(FileSystem.GetRootNode(), path)
					if(node.IsFile())
					{
						if(String.EndsWith(node.GetName(), ".bsh"))
						{
							return function() => return RunShellScript(path)
						}
						else
						{
							if(String.EndsWith(node.GetName(), ".bs"))
							{
								return function(*args) => return RunProcess(path, args)
							}
						}
					}
				}
				return null
			}

			function Equals(l, r)
			{
				return l == r
			}

			function NotEquals(l, r)
			{
				return l != r
			}

			function Less(l, r)
			{
				return l < r
			}

			function LessOrEqual(l, r)
			{
				return l <= r
			}

			function Greater(l, r)
			{
				return l > r
			}

			function GreaterOrEqual(l, r)
			{
				return l >= r
			}

			function ChangeDir(?dir)
			{	
				if(dir != null)
				{
					fullPath = FileSystem.ResolvePath(dir, ProcessInfo.GetWorkingDirectory())
				
					if(FileSystem.Exists(FileSystem.GetRootNode(), fullPath))
					{
						node = FileSystem.FindNode(FileSystem.GetRootNode(), fullPath)
						ProcessInfo.SetWorkingDirectory(node.GetFullName())
					}
					else
					{
						Logger.Warn($"Can not Find Path: {fullPath}")
					}
				}
				return ProcessInfo.GetWorkingDirectory()
			}

			__shell.GetRootScope().AddNamedHook("eq", Equals)
			__shell.GetRootScope().AddNamedHook("ne", NotEquals)
			__shell.GetRootScope().AddNamedHook("lt", Less)
			__shell.GetRootScope().AddNamedHook("le", LessOrEqual)
			__shell.GetRootScope().AddNamedHook("gt", Greater)
			__shell.GetRootScope().AddNamedHook("ge", GreaterOrEqual)

			__shell.GetRootScope().AddNamedHook("cd", ChangeDir)


			function ExitShell()
			{
				__exited = true
				exitFunc()
			}

			__shell.GetRootScope().AddNamedHook("exit", ExitShell)
			__shell.GetRootScope().AddScopeHook(PathResolver)


			if(startFiles.Size() != 0)
			{
				foreach file in startFiles
				{
					RunShellScript(file)
				}
			}
			
		}
	}
}

function BadShellMain()
{
	args = ProcessInfo.GetArguments()
	args.RemoveAt(0)
	onlyFiles = false
	if(args.Size() != 0)
	{
		if(args[0] == "--file")
		{
			onlyFiles = true
			args.RemoveAt(0)
		}
	}
	exit = false
	shell = new BadShellModule(ProcessInfo, Extensions, args, function() => exit = true)
	if(!onlyFiles)
	{
		while(!exit)
		{
			shell.OnUpdate()
			Environment.Sleep(250)
		}
	}

}

BadShellMain()
