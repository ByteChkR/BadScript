namespace BadShell
{


	class BadShellModule
	{
		ProcessInfo = null
		Console = null
		Extension = null

		__exited = false
		__shell = null


		__currentCommand = ""
		__firstUpdate = true

		function WritePrefix()
		{
			Console.Write($"{ProcessInfo.GetUser().GetName()}@{OS.GetMachineName()}: {ProcessInfo.GetWorkingDirectory()}$")
		}

		function OnUpdate()
		{
			if(__firstUpdate)
			{
				__firstUpdate = false
				WritePrefix()
			}

			while(true)
			{
				c = Console.ReadChar()
				if(c == "\0")
				{
					break
				}
				if(c == "\n" && __currentCommand != "")
				{
					__shell.RunScript(__currentCommand)
					__currentCommand = ""
					if(!__exited)
					{
						WritePrefix()
					}
					break
				}
				if(c != "\n" && c != "\r")
				{
					__currentCommand += c
				}
				else if(c == "\n")
				{
					WritePrefix()
				}
			}
		}

		function BadShellModule(!pinfo, !extensions, !startFiles, !exitFunc)
		{
			Extensions = extensions
			ProcessInfo = pinfo
			l = Extensions.GetExtension(ProcessInfo.GetUser(), "BadOS.Extensions.Logging")
			_logger = l.CreateLogger("BadShell")
			Console = Extensions.GetExtension(ProcessInfo.GetUser(), "BadOS.Extensions.Console")
			ConcurrencySystem = Extensions.GetExtension(ProcessInfo.GetUser(), "BadOS.Extensions.Concurrency")
			FileSystem = Extensions.GetExtension(ProcessInfo.GetUser(), "BadOS.Extensions.FileSystem")

			__shell = new ShellTest(Console)

			function RunProcess(file, args)
			{
				user = ProcessInfo.GetUser()
				file = ProcessInfo.ResolvePath(file)
				node = FileSystem.FindNode(FileSystem.GetRootNode(), file)
				if(node.IsFile())
				{
					src = node.ReadAllText(user)
					args.Insert(0, file)
					return ConcurrencySystem.StartSynchronousProcess(user, src, args, ProcessInfo.GetWorkingDirectory(), file)
				}
				else
				{
					Environment.Error($"{file} is not a File")
				}
				return null
			}

			function RunShellScript(!file)
			{
				if(FileSystem.Exists(FileSystem.GetRootNode(), file))
				{
					src = FileSystem.FindNode(FileSystem.GetRootNode(), file).ReadAllText(ProcessInfo.GetUser())
					return __shell.RunRootScript(src)
				}
				return null
			}

			function PathResolver(!path)
			{
				if(FileSystem.Exists(FileSystem.GetRootNode(), path))
				{
					node = FileSystem.FindNode(FileSystem.GetRootNode(), path)
					if(node.IsFile())
					{
						if(String.EndsWith(node.GetName(), ".bsh"))
						{
							return function() => return RunShellScript(path)
						}
						else
						{
							if(String.EndsWith(node.GetName(), ".bs"))
							{
								return function(*args) => return RunProcess(path, args)
							}
						}
					}
				}
				return null
			}

			function Equals(l, r)
			{
				return l == r
			}

			function NotEquals(l, r)
			{
				return l != r
			}

			function Less(l, r)
			{
				return l < r
			}

			function LessOrEqual(l, r)
			{
				return l <= r
			}

			function Greater(l, r)
			{
				return l > r
			}

			function GreaterOrEqual(l, r)
			{
				return l >= r
			}

			function ChangeDir(?dir)
			{	
				if(dir != null)
				{
					fullPath = FileSystem.ResolvePath(dir, ProcessInfo.GetWorkingDirectory())
				
					if(FileSystem.Exists(FileSystem.GetRootNode(), fullPath))
					{
						node = FileSystem.FindNode(FileSystem.GetRootNode(), fullPath)
						ProcessInfo.SetWorkingDirectory(node.GetFullName())
					}
					else
					{
						Logger.Warn($"Can not Find Path: {fullPath}")
					}
				}
				return ProcessInfo.GetWorkingDirectory()
			}

			__shell.GetRootScope().AddNamedHook("eq", Equals)
			__shell.GetRootScope().AddNamedHook("ne", NotEquals)
			__shell.GetRootScope().AddNamedHook("lt", Less)
			__shell.GetRootScope().AddNamedHook("le", LessOrEqual)
			__shell.GetRootScope().AddNamedHook("gt", Greater)
			__shell.GetRootScope().AddNamedHook("ge", GreaterOrEqual)

			__shell.GetRootScope().AddNamedHook("cd", ChangeDir)


			function ExitShell()
			{
				__exited = true
				exitFunc()
			}

			__shell.GetRootScope().AddNamedHook("exit", ExitShell)
			__shell.GetRootScope().AddScopeHook(PathResolver)


			if(startFiles.Size() != 0)
			{
				foreach file in startFiles
				{
					RunShellScript(file)
				}
			}
			
		}
	}
}